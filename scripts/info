#!/usr/bin/env node
const debug = require('debug');
const log = debug('@pie-element:scripts:build');
const { processFix, watch } = require('@pie-framework/build-helper');
const argv = require('minimist')(process.argv.slice(2));
const fs = require('fs-extra');
const spawn = require('child-process').spawn;
const rimraf = require('rimraf');
const _ = require('lodash');

let processes;
let info;
processFix(log, () => {
  process.exit();

  if (processes) {
    processes.exit();
  }

  if (info) {
    info.kill();
  }
});

log('pkg: ', argv._[0]);
const pkg = argv._[0];

const getWatchesForPie = async p => {
  const out = [];
  if (await fs.exists(`packages/${p}/src`)) {
    out.push({
      src: `packages/${p}/src`,
      target: `packages/${p}/lib`
    });
  }

  if (await fs.exists(`packages/${p}/configure/src`)) {
    out.push({
      src: `packages/${p}/configure/src`,
      target: `packages/${p}/configure/lib`
    });
  }
  if (await fs.exists(`packages/${p}/controller/src`)) {
    out.push({
      src: `packages/${p}/controller/src`,
      target: `packages/${p}/controller/lib`
    });
  }

  return out;
};

const run = async () => {
  const watches = await getWatchesForPie(pkg);
  processes = watch(watches);
  info = spawn('pie', ['info'], { cwd: `packages/${pkg}`, stdio: 'inherit' });
};

// const listPackages = () => fs.readdir('packages');

// const getPackages = async () => {
//   if (argv.scope) {
//     return Promise.resolve(
//       Array.isArray(argv.scope) ? argv.scope : [argv.scope]
//     );
//   } else {
//     return await listPackages();
//   }
// };

// argv.clean = argv.clean !== false;
// argv.onlyClean = argv.onlyClean === true;

// const cleanLib = p =>
//   new Promise((resolve, reject) => {
//     const lib = `${p}/lib`;
//     log('clean: ', lib);
//     rimraf(lib, e => {
//       if (e) {
//         reject(e);
//       } else {
//         resolve();
//       }
//     });
//   });

// const buildDir = p => {
//   log(`build: ${p}`);

//   const args = [
//     `${p}/src`,
//     '--out-dir',
//     `${p}/lib`,
//     '--ignore',
//     '/__test__/,/__tests__/,/__mocks__/'
//   ];
//   return spawn('./node_modules/.bin/babel', args, {
//     stdio: 'inherit'
//   });
// };

// const getFolders = async name => {
//   log('getFolders: ', name);
//   const n = `packages/${name}`;
//   const stat = await fs.stat(n);
//   const out = [];

//   if (stat.isDirectory()) {
//     const files = await fs.readdir(n);
//     if (files.indexOf('src') !== -1) {
//       out.push(n);
//     }

//     if (files.indexOf('controller') !== -1) {
//       out.push(`${n}/controller`);
//     }

//     if (files.indexOf('configure') !== -1) {
//       out.push(`${n}/configure`);
//     }
//     return Promise.all(out);
//   } else {
//     return Promise.resolve([]);
//   }
// };

// const cleanPackage = async name => {
//   const folders = await getFolders(name);
//   return Promise.all(folders.map(cleanLib));
// };

// const buildPackage = async name => {
//   const folders = await getFolders(name);
//   return Promise.all(folders.map(buildDir));
// };

// const run = async () => {
//   const packages = await getPackages();

//   log('packages: ', packages);

//   if (argv.clean || argv.onlyClean) {
//     await Promise.all(packages.map(cleanPackage));
//     log('clean done.');
//   }

//   if (!argv.onlyClean) {
//     const buildPromises = packages.map(p => buildPackage(p));

//     Promise.all(buildPromises)
//       .then(() => {
//         log('---------> done');
//       })
//       .catch(e => {
//         log('error', e);
//       });
//   }
// };

// run();
